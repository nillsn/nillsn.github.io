(()=>{"use strict";class e{static getActualRoute(){return new URLSearchParams(window.location.search).get("route")}static validate(t){const r=e.getActualRoute();null!==r?!0!==t[r]&&window.location.replace("?route=404"):window.location.replace("?route=index")}}class t{static build(e,r,o){r.innerHTML=o,t.updateForEach(r),t.updateProperty(r),t.updateClickEvents(e,r,o),t.updateStaticClickEvents(e,r,o),t.setFocus()}static use(e,t){customElements.define(t,e)}static useOnRoute(r,o,a){e.getActualRoute()===a&&t.use(r,o)}static updateForEach(e){e.querySelectorAll("[forEach]").forEach((t=>{const r=t.parentNode,o=t.getAttribute("forEach"),a=e[o];void 0!==a&&(a.forEach((e=>{const o=t.cloneNode(!0);o.querySelectorAll("[forEachHere]").forEach((t=>{const r=t.getAttribute("forEachHere");t.innerText=""===r?e:e[r]})),r.append(o)})),t.remove())}))}static updateProperty(e){e.querySelectorAll("[property]").forEach((t=>{const r=t.getAttribute("property"),o=e[r];t.innerText=o}))}static updateClickEvents(e,r,o){r.querySelectorAll("[click]").forEach((a=>{const n=a.getAttribute("click");void 0!==r[n]&&a.addEventListener("click",(()=>{r[n](),t.build(e,r,o)}))}))}static updateStaticClickEvents(e,r,o){r.querySelectorAll("[static]").forEach((a=>{const n=a.getAttribute("static"),s=e[n];void 0!==s&&a.addEventListener("click",(()=>{s(),t.build(e,r,o)}))}))}static setFocus(){const e=document.querySelector("[focus]");null!==e&&e.focus()}}class r extends HTMLElement{connectedCallback(){t.build(r,this,"<pagenotfound-component></pagenotfound-component> <index-component></index-component> <configuration-component></configuration-component> <game-component></game-component>")}}class o extends HTMLElement{connectedCallback(){t.build(o,this,"<h1>#404 - Page Not Found Exception</h1>")}}class a{static throwErrorIfUndefined(e){if(void 0===e)throw new Error("PropertyGuardError: parameter is undefined")}static throwErrorIfNoString(e){if("string"!=typeof e)throw new Error("PropertyGuardError: parameter is not a string")}static throwErrorIfNoArrayOfStrings(e){e.forEach((e=>{try{this.throwErrorIfNoString(e)}catch{throw new Error("PropertyGuardError: parameter is not an array of strings")}}))}static throwErrorIfNoNumber(e){if("number"!=typeof e)throw new Error("PropertyGuardError: parameter is not a number")}static throwErrorIfNoArrayOfNumbers(e){e.forEach((e=>{try{this.throwErrorIfNoNumber(e)}catch{throw new Error("PropertyGuardError: parameter is not an array of numbers")}}))}static throwErrorIfNoBoolean(e){if("boolean"!=typeof e)throw new Error("PropertyGuardError: parameter is not a boolean")}static throwErrorIfNoArrayOfBooleans(e){e.forEach((e=>{try{this.throwErrorIfNoBoolean(e)}catch{throw new Error("PropertyGuardError: parameter is not an array of booleans")}}))}static throwErrorIfNoArray(e){if(!1===Array.isArray(e))throw new Error("PropertyGuardError: parameter is not an array")}static throwErrorIfNoObject(e){if("object"!=typeof e)throw new Error("PropertyGuardError: parameter is not an object")}static throwErrorIfNoArrayOfObjects(e){e.forEach((e=>{try{this.throwErrorIfNoObject(e)}catch{throw new Error("PropertyGuardError: parameter is not an array of objects")}}))}static throwErrorIfItemIsNotInArray(e,t){if(this.throwErrorIfUndefined(e),this.throwErrorIfNoArray(t),!1===t.includes(e))throw new Error("PropertyGuardError: item is not part of the array")}}const n="jsonGameCollection";class s{static create(e,t){a.throwErrorIfNoArrayOfStrings(e),a.throwErrorIfNoNumber(t),a.throwErrorIfItemIsNotInArray(t,[101,170,301,501]);const r={};e.forEach((e=>{const o={sets:0,legs:0,required:t,throws:[],average:"-",highestScore:"-",highestFinish:"-",currentLegThrows:[]};r[e]=o}));const o=new Date,n=`${o.toDateString()}, ${o.toLocaleTimeString()}`;return{playerNames:e,playerStats:r,gameMode:t,createdDate:o,createdDateString:n}}static getGame(e){const t=localStorage.getItem(n);if(null!==t)return JSON.parse(t)[e]}static setGame(e,t){const r=localStorage.getItem(n);if(null===r){const r={};r[e]=t,localStorage.setItem(n,JSON.stringify(r))}else{const o=JSON.parse(r);o[e]=t,localStorage.setItem(n,JSON.stringify(o))}}static buildPlayerStatsArray(e){s.validate(e);const{playerNames:t,playerStats:r}=e,o=[];return t.forEach((e=>{const t=r[e],a={name:e,sets:t.sets,legs:t.legs,required:t.required,throws:t.throws,average:t.average,highestScore:t.highestScore,highestFinish:t.highestFinish};"-"!==a.average&&(a.average=Number.parseFloat(a.average).toFixed(2)),o.push(a)})),o}static getNextPlayer(e){s.validate(e);let t=0,r=0;e.playerNames.forEach((o=>{const a=e.playerStats[o];t+=a.sets,r+=a.legs}));const o=class{static rotate(e,t,r){const o=JSON.parse(JSON.stringify(e)),a=t+r;for(let e=0;e<a;e+=1)o.push(o.shift());return o}}.rotate(e.playerNames,t,r);let a=o[0],n=e.playerStats[a].currentLegThrows.length;for(let t=1;t<o.length;t+=1){const r=o[t],s=e.playerStats[r].currentLegThrows.length;s<n&&(a=r,n=s)}return a}static submitScore(e,t){if(s.validate(e),a.throwErrorIfNoNumber(t),t<0||t>180)return e;const r=s.getNextPlayer(e),o=e.playerStats[r];if(t>o.required)return e;o.required-=t,o.throws.push(t),o.currentLegThrows.push(t),("-"===o.highestScore||o.highestScore<t)&&(o.highestScore=t);let n=0;if(o.throws.forEach((e=>{n+=e})),o.average=n/o.throws.length,0===o.required){("-"===o.highestFinish||o.highestFinish<t)&&(o.highestFinish=t),o.legs+=1;let r=!1;3===o.legs&&(r=!0,o.sets+=1),e.playerNames.forEach((t=>{const o=e;o.playerStats[t].required=e.gameMode,o.playerStats[t].currentLegThrows=[],r&&(o.playerStats[t].legs=0)}))}return e}static validate(e){a.throwErrorIfUndefined(e),a.throwErrorIfNoObject(e);const{playerNames:t,playerStats:r}=e;a.throwErrorIfNoArrayOfStrings(t),a.throwErrorIfNoObject(r)}static countOldGames(){return s.getOldGameIds().length}static countNewGames(){return s.getNewGameIds().length}static getOldGameIds(){const e=[];return Object.keys(localStorage).forEach((t=>{if(16===t.length)try{const r=JSON.parse(localStorage.getItem(t));s.validate(r),e.push(t)}catch{console.log("failed:",t)}})),e}static getNewGameIds(){const e=localStorage.getItem(n);if(null===e)return[];const t=[];return Object.keys(JSON.parse(e)).forEach((e=>{t.push(e)})),t}static performMerge(){s.getOldGameIds().forEach((e=>{const t=localStorage.getItem(e);try{const r=JSON.parse(t);s.validate(r),s.setGame(e,r)}catch(t){console.log("Error:",t,"Id:",e)}})),alert("done")}}class i extends HTMLElement{connectedCallback(){t.build(i,this,'<h3>AppSwitch</h3> <button static="openConfig">Create Dart Game</button> <button static="countGames">Count Games</button> <button static="merge">Merge Games</button>')}static openConfig(){window.location="?route=config"}static countGames(){const e=s.countOldGames(),t=s.countNewGames();alert(`You have ${e} old games and ${t} new games.`)}static merge(){const e=s.countOldGames();e>0?confirm(`i found ${e} games that can be merged`)&&s.performMerge():alert("there are no old games that you can merge")}}class c extends HTMLElement{connectedCallback(){t.build(c,this,'<h3>Game Configuration</h3> <label><h5>Number of Players</h5></label> <select id="numberOfPlayers" required> <option value="1">1 Player</option> <option value="2" selected="selected">2 Players</option> <option value="3">3 Players</option> <option value="4">4 Players</option> <option value="5">5 Players</option> <option value="6">6 Players</option> </select> <br> <br> <label><h5>Player Names</h5></label> <input id="player1" type="text" placeholder="Player 1" value="Player 1"> <input id="player2" type="text" placeholder="Player 2" value="Player 2"> <input id="player3" type="text" placeholder="Player 3" value="Player 3" hidden> <input id="player4" type="text" placeholder="Player 4" value="Player 4" hidden> <input id="player5" type="text" placeholder="Player 5" value="Player 5" hidden> <input id="player6" type="text" placeholder="Player 6" value="Player 6" hidden> <button static="createGame">Game On</button>');const e=document.getElementById("numberOfPlayers");c.showInputFieldsForNumberOfPlayers(e.value),e.addEventListener("change",(()=>{c.showInputFieldsForNumberOfPlayers(e.value)}))}static showInputFieldsForNumberOfPlayers(e){const t=document.getElementById("player2"),r=document.getElementById("player3"),o=document.getElementById("player4"),a=document.getElementById("player5"),n=document.getElementById("player6");"1"===e&&(t.setAttribute("hidden",""),r.setAttribute("hidden",""),o.setAttribute("hidden",""),a.setAttribute("hidden",""),n.setAttribute("hidden","")),"2"===e&&(t.removeAttribute("hidden"),r.setAttribute("hidden",""),o.setAttribute("hidden",""),a.setAttribute("hidden",""),n.setAttribute("hidden","")),"3"===e&&(t.removeAttribute("hidden"),r.removeAttribute("hidden"),o.setAttribute("hidden",""),a.setAttribute("hidden",""),n.setAttribute("hidden","")),"4"===e&&(t.removeAttribute("hidden"),r.removeAttribute("hidden"),o.removeAttribute("hidden"),a.setAttribute("hidden",""),n.setAttribute("hidden","")),"5"===e&&(t.removeAttribute("hidden"),r.removeAttribute("hidden"),o.removeAttribute("hidden"),a.removeAttribute("hidden"),n.setAttribute("hidden","")),"6"===e&&(t.removeAttribute("hidden"),r.removeAttribute("hidden"),o.removeAttribute("hidden"),a.removeAttribute("hidden"),n.removeAttribute("hidden"))}static async createGame(){const e=document.getElementById("numberOfPlayers").value,t=document.getElementById("player1").value,r=document.getElementById("player2").value,o=document.getElementById("player3").value,a=document.getElementById("player4").value,n=document.getElementById("player5").value,i=document.getElementById("player6").value,l=[t];if("2"===e&&l.push(r),"3"===e&&(l.push(r),l.push(o)),"4"===e&&(l.push(r),l.push(o),l.push(a)),"5"===e&&(l.push(r),l.push(o),l.push(a),l.push(n)),"6"===e&&(l.push(r),l.push(o),l.push(a),l.push(n),l.push(i)),!0===c.duplicatePlayerNameCheck(l)){const e=s.create(l,501),t=await c.generateRandomKey();s.setGame(t,e),window.location=`?route=game&id=${t}`}}static async generateRandomKey(){const e=(new TextEncoder).encode(Math.random()),t=await crypto.subtle.digest("SHA-512",e);return Array.from(new Uint8Array(t)).map((e=>e.toString(16).padStart(2,"0"))).join("").substr(0,16)}static duplicatePlayerNameCheck(e){let t=!0;return e.forEach((r=>{e.filter((e=>e===r)).length>1&&(t=!1)})),t}}class l extends HTMLElement{constructor(){super();const e=l.getGameId(),t=s.getGame(e);if(void 0===t)throw new Error("Game ID is invalid!");this.game=t,this.updateComponent()}connectedCallback(){t.build(l,this,'<h3>Good Flight, <span property="nextPlayer"></span>!</h3> <table role="grid"> <thead> <tr> <th scope="col">Player</th> <th scope="col">Sets</th> <th scope="col">Legs</th> <th scope="col">Required</th> </tr> </thead> <tbody> <tr forEach="playerStats"> <th scope="row" forEachHere="name"></th> <td forEachHere="sets"></td> <td forEachHere="legs"></td> <td forEachHere="required"></td> </tr> </tbody> </table> <input id="score" type="number" value="" min="0" max="180" focus> <button click="submitScore">Submit</button> <h3>Additional Stats</h3> <table role="grid"> <thead> <tr> <th scope="col">Player</th> <th scope="col">Highest Score</th> <th scope="col">Highest Finish</th> <th scope="col">Average</th> </tr> </thead> <tbody> <tr forEach="playerStats"> <th scope="row" forEachHere="name"></th> <td forEachHere="highestScore"></td> <td forEachHere="highestFinish"></td> <td forEachHere="average"></td> </tr> </tbody> </table>')}static getGameId(){const e=new URLSearchParams(window.location.search).get("id");if(null===e)throw new Error("Game ID is null!");return e}updateComponent(){this.playerStats=s.buildPlayerStatsArray(this.game),this.nextPlayer=s.getNextPlayer(this.game)}submitScore(){const e=document.getElementById("score"),{value:t}=e,r=parseInt(t,10);if(Number.isNaN(r))throw new Error("Invalid score: input ist not a number");if(r<0||r>180)throw new Error(`Invalid score of: ${r}`);this.game=s.submitScore(this.game,r);const o=l.getGameId();s.setGame(o,this.game),this.updateComponent()}}e.validate({404:!0,index:!0,config:!0,game:!0}),t.use(r,"app-component"),t.useOnRoute(o,"pagenotfound-component","404"),t.useOnRoute(i,"index-component","index"),t.useOnRoute(c,"configuration-component","config"),t.useOnRoute(l,"game-component","game")})();